###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         29/Dec/2017  20:30:04 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  D:\ProgramData\Hardware\zigbee\Projects\zstack\Sam #
#                          ples\SensorSys\Source\SensorSys_Coordinator.c      #
#    Command line       =  -f D:\ProgramData\Hardware\zigbee\Projects\zstack\ #
#                          Samples\SensorSys\CC2530DB\..\..\..\Tools\CC2530DB #
#                          \f8wCoord.cfg (-DCPU32MHZ -DROOT=__near_func       #
#                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                   #
#                          -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8         #
#                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)    #
#                          -f D:\ProgramData\Hardware\zigbee\Projects\zstack\ #
#                          Samples\SensorSys\CC2530DB\..\..\..\Tools\CC2530DB #
#                          \f8wConfig.cfg (-DZIGBEEPRO -DSECURE=0             #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFF1                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 D:\ProgramData\Hardware\zig #
#                          bee\Projects\zstack\Samples\SensorSys\Source\Senso #
#                          rSys_Coordinator.c -D HOLD_AUTO_START -D           #
#                          BUILD_ALL_DEVICES -D REFLECTOR -D NV_INIT -D       #
#                          xNV_RESTORE -D xZTOOL_P1 -D xMT_TASK -D            #
#                          xMT_SYS_FUNC -D xMT_SAPI_FUNC -D xMT_SAPI_CB_FUNC  #
#                          -lC D:\ProgramData\Hardware\zigbee\Projects\zstack #
#                          \Samples\SensorSys\CC2530DB\CoordinatorEB\List\    #
#                          -lA D:\ProgramData\Hardware\zigbee\Projects\zstack #
#                          \Samples\SensorSys\CC2530DB\CoordinatorEB\List\    #
#                          --diag_suppress Pe001,Pa010 -o                     #
#                          D:\ProgramData\Hardware\zigbee\Projects\zstack\Sam #
#                          ples\SensorSys\CC2530DB\CoordinatorEB\Obj\ -e      #
#                          --no_code_motion --debug --core=plain --dptr=16,1  #
#                          --data_model=large --code_model=banked             #
#                          --calling_convention=xdata_reentrant               #
#                          --place_constants=data_rom --nr_virtual_regs 16    #
#                          -I D:\ProgramData\Hardware\zigbee\Projects\zstack\ #
#                          Samples\SensorSys\CC2530DB\ -I                     #
#                          D:\ProgramData\Hardware\zigbee\Projects\zstack\Sam #
#                          ples\SensorSys\CC2530DB\..\Source\ -I              #
#                          D:\ProgramData\Hardware\zigbee\Projects\zstack\Sam #
#                          ples\SensorSys\CC2530DB\..\..\..\ZMain\TI2530DB\   #
#                          -I D:\ProgramData\Hardware\zigbee\Projects\zstack\ #
#                          Samples\SensorSys\CC2530DB\..\..\..\..\..\Componen #
#                          ts\hal\include\ -I D:\ProgramData\Hardware\zigbee\ #
#                          Projects\zstack\Samples\SensorSys\CC2530DB\..\..\. #
#                          .\..\..\Components\hal\target\CC2530EB\ -I         #
#                          D:\ProgramData\Hardware\zigbee\Projects\zstack\Sam #
#                          ples\SensorSys\CC2530DB\..\..\..\..\..\Components\ #
#                          mac\include\ -I D:\ProgramData\Hardware\zigbee\Pro #
#                          jects\zstack\Samples\SensorSys\CC2530DB\..\..\..\. #
#                          .\..\Components\mac\high_level\ -I                 #
#                          D:\ProgramData\Hardware\zigbee\Projects\zstack\Sam #
#                          ples\SensorSys\CC2530DB\..\..\..\..\..\Components\ #
#                          mac\low_level\srf04\ -I D:\ProgramData\Hardware\zi #
#                          gbee\Projects\zstack\Samples\SensorSys\CC2530DB\.. #
#                          \..\..\..\..\Components\mac\low_level\srf04\single #
#                          _chip\ -I D:\ProgramData\Hardware\zigbee\Projects\ #
#                          zstack\Samples\SensorSys\CC2530DB\..\..\..\..\..\C #
#                          omponents\mt\ -I D:\ProgramData\Hardware\zigbee\Pr #
#                          ojects\zstack\Samples\SensorSys\CC2530DB\..\..\..\ #
#                          ..\..\Components\osal\include\ -I                  #
#                          D:\ProgramData\Hardware\zigbee\Projects\zstack\Sam #
#                          ples\SensorSys\CC2530DB\..\..\..\..\..\Components\ #
#                          services\saddr\ -I D:\ProgramData\Hardware\zigbee\ #
#                          Projects\zstack\Samples\SensorSys\CC2530DB\..\..\. #
#                          .\..\..\Components\services\sdata\ -I              #
#                          D:\ProgramData\Hardware\zigbee\Projects\zstack\Sam #
#                          ples\SensorSys\CC2530DB\..\..\..\..\..\Components\ #
#                          stack\af\ -I D:\ProgramData\Hardware\zigbee\Projec #
#                          ts\zstack\Samples\SensorSys\CC2530DB\..\..\..\..\. #
#                          .\Components\stack\nwk\ -I                         #
#                          D:\ProgramData\Hardware\zigbee\Projects\zstack\Sam #
#                          ples\SensorSys\CC2530DB\..\..\..\..\..\Components\ #
#                          stack\sapi\ -I D:\ProgramData\Hardware\zigbee\Proj #
#                          ects\zstack\Samples\SensorSys\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\sec\ -I                       #
#                          D:\ProgramData\Hardware\zigbee\Projects\zstack\Sam #
#                          ples\SensorSys\CC2530DB\..\..\..\..\..\Components\ #
#                          stack\sys\ -I D:\ProgramData\Hardware\zigbee\Proje #
#                          cts\zstack\Samples\SensorSys\CC2530DB\..\..\..\..\ #
#                          ..\Components\stack\zdo\ -I                        #
#                          D:\ProgramData\Hardware\zigbee\Projects\zstack\Sam #
#                          ples\SensorSys\CC2530DB\..\..\..\..\..\Components\ #
#                          zmac\ -I D:\ProgramData\Hardware\zigbee\Projects\z #
#                          stack\Samples\SensorSys\CC2530DB\..\..\..\..\..\Co #
#                          mponents\zmac\f8w\ -Ohz --require_prototypes       #
#    List file          =  D:\ProgramData\Hardware\zigbee\Projects\zstack\Sam #
#                          ples\SensorSys\CC2530DB\CoordinatorEB\List\SensorS #
#                          ys_Coordinator.lst                                 #
#    Object file        =  D:\ProgramData\Hardware\zigbee\Projects\zstack\Sam #
#                          ples\SensorSys\CC2530DB\CoordinatorEB\Obj\SensorSy #
#                          s_Coordinator.r51                                  #
#                                                                             #
#                                                                             #
###############################################################################

D:\ProgramData\Hardware\zigbee\Projects\zstack\Samples\SensorSys\Source\SensorSys_Coordinator.c
      1          /**************************************************************************************************
      2            Filename:       Sys.c
      3            Revised:        $Date: 2009-03-18 15:56:27 -0700 (Wed, 18 Mar 2009) $
      4            Revision:       $Revision: 19453 $
      5          
      6            Description:    Generic Application (no Profile).
      7          
      8          
      9            Copyright 2004-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41            This application isn't intended to do anything useful, it is
     42            intended to be a simple example of an application's structure.
     43          
     44            This application sends "Hello World" to another "Generic"
     45            application every 15 seconds.  The application will also
     46            receive "Hello World" packets.
     47          
     48            The "Hello World" messages are sent/received as MSG type message.
     49          
     50            This applications doesn't have a profile, so it handles everything
     51            directly - itself.
     52          
     53            Key control:
     54              SW1:
     55              SW2:  initiates end device binding
     56              SW3:
     57              SW4:  initiates a match description request
     58          *********************************************************************/
     59          
     60          /*********************************************************************
     61           * INCLUDES
     62           */
     63          #include "AF.h"
     64          #include "ZDObject.h"
     65          #include "ZDProfile.h"
     66          #include "sapi.h"
     67          
     68          #include "SensorSys_Coor.h"

  #define ALLOW_BIND_TIMER       0x0020
          ^
"D:\ProgramData\Hardware\zigbee\Projects\zstack\Samples\SensorSys\Source\SensorSys_Coor.h",50  Warning[Pe047]: 
          incompatible redefinition of macro "ALLOW_BIND_TIMER" (declared at
          line 87 of
          "D:\ProgramData\Hardware\zigbee\Projects\zstack\Samples\SensorSys\Sou
          rce\SensorSys_End.h")
     69          #include "DebugTrace.h"
     70          
     71          #if !defined( WIN32 )
     72            #include "OnBoard.h"
     73          #endif
     74          
     75          /* HAL */
     76          #include "hal_led.h"
     77          #include "hal_key.h"
     78          #include "hal_uart.h"
     79          
     80          #include "nwk.h"
     81          #include "APS.h"
     82          #include "ZDApp.h"
     83          #include "OSAL.h"
     84          #include "OSAL_Tasks.h"
     85          #include "ZComDef.h"
     86          #include "hal_drivers.h"
     87          /*********************************************************************
     88           * MACROS
     89           */
     90          
     91          /*********************************************************************
     92           * CONSTANTS
     93           */
     94          
     95          /*********************************************************************
     96           * TYPEDEFS
     97           */
     98          #define SAPICB_BIND_CNF   0xE1
     99          /*********************************************************************
    100           * GLOBAL VARIABLES
    101           */
    102          uint8 AppTitle[]="SensorAPP"; //应用程序名称
    103          
    104          // Sys 端点的簇ID
    105          // This list should be filled with Application specific Cluster IDs.
    106          const cId_t Sys_ClusterList[SYS_MAX_CLUSTERS] =
    107          {
    108            SYS_CLUSTERID
    109          };
    110          
    111          const cId_t Zb_ClusterList[ZB_MAX_CLUSTERS] =
    112          {
    113            ZB_CLUSTERID
    114          };
    115          
    116          // Sys 端点简单描述符
    117          const SimpleDescriptionFormat_t Sys_SimpleDesc =
    118          {
    119          	SYS_ENDPOINT,           //  int Endpoint;
    120          	SYS_PROFID,                //  uint16 AppProfId[2];
    121          	SYS_DEVICEID,              //  uint16 AppDeviceId[2];
    122          	SYS_DEVICE_VERSION,        //  int   AppDevVer:4;
    123          	SYS_FLAGS,                 //  int   AppFlags:4;
    124          	SYS_MAX_CLUSTERS,          //  byte  AppNumInClusters;
    125          	(cId_t *)Sys_ClusterList,  //  byte *pAppInClusterList;
    126          	0,                         //  byte  AppNumInClusters;
    127          	NULL   //  byte *pAppInClusterList;
    128          };
    129          
    130          const SimpleDescriptionFormat_t zb_SimpleDesc =
    131          {
    132          	ZB_ENDPOINT,           //  int Endpoint;
    133          	SYS_PROFID,                //  uint16 AppProfId[2];
    134          	SYS_DEVICEID,              //  uint16 AppDeviceId[2];
    135          	SYS_DEVICE_VERSION,        //  int   AppDevVer:4;
    136          	SYS_FLAGS,                 //  int   AppFlags:4;
    137          	ZB_MAX_CLUSTERS,          //  byte  AppNumInClusters;
    138          	(cId_t *)Zb_ClusterList,  //  byte *pAppInClusterList;
    139          	ZB_MAX_CLUSTERS,          //  byte  AppNumInClusters;
    140          	(cId_t *)Zb_ClusterList   //  byte *pAppInClusterList;
    141          };
    142          
    143          // This is the Endpoint/Interface description.  It is defined here, but
    144          // filled-in in Button_Init().  Another way to go would be to fill
    145          // in the structure here and make it a "const" (in code space).  The
    146          // way it's defined in this sample app it is define in RAM.
    147          endPointDesc_t Sys_epDesc;
    148          
    149          /*********************************************************************
    150           * LOCAL VARIABLES
    151           */
    152          uint8 myAppState = APP_INIT;
    153          
    154          static byte type_join;
    155          
    156          byte Sys_TaskID;
    157          
    158          devStates_t Sys_NwkState;   // 节点现在的网络状态
    159          
    160          
    161          byte Sys_TransID;  // 数据包的发送ID，每发一个自增1
    162          
    163          uint8 sysSeqNumber = 0;    // 在端点间数据交流时被使用zb_SendDataRequest
    164          
    165          uint16 sensor_bindInProgress;
    166          /*********************************************************************
    167           * LOCAL FUNCTIONS
    168           */
    169          void Sys_Init( byte task_id );
    170          
    171          UINT16 Sys_ProcessEvent( byte task_id, UINT16 events );
    172          
    173          void Sys_ProcessZDOMsgs( zdoIncomingMsg_t *inMsg );
    174          
    175          void Sys_MessageMSGCB( afIncomingMSGPacket_t *pckt, byte task_id );
    176          void Sys_SendPreBindMessage( byte type_id );
    177          
    178          void Sensor_BindDevice ( uint8 create, uint16 commandId, uint8 *pDestination );
    179          
    180          uint8 typeID2pointID(char type);
    181          
    182          
    183          /*********************************************************************
    184           * NETWORK LAYER CALLBACKS
    185           */
    186          
    187          /*********************************************************************
    188           * PUBLIC FUNCTIONS
    189           */
    190          
    191          /*********************************************************************
    192           * @fn      Sys_Init
    193           *
    194           * @brief   Initialization function for the Generic App Task.
    195           *          This is called during initialization and should contain
    196           *          any application specific initialization (ie. hardware
    197           *          initialization/setup, table initialization, power up
    198           *          notificaiton ... ).
    199           *
    200           * @param   task_id - the ID assigned by OSAL.  This ID should be
    201           *                    used to send messages and set timers.
    202           *
    203           * @return  none
    204           */
    205          void Sys_Init( byte task_id )
    206          {
    207            Sys_TaskID = task_id;
    208          
    209            // Fill out the endpoint description.
    210            Sys_epDesc.endPoint = SYS_ENDPOINT;
    211            Sys_epDesc.task_id = &Sys_TaskID;
    212            Sys_epDesc.simpleDesc
    213                      = (SimpleDescriptionFormat_t *)&Sys_SimpleDesc;
    214            Sys_epDesc.latencyReq = noLatencyReqs;
    215          
    216            // Register the endpoint description with the AF
    217            afRegister( &Sys_epDesc );
    218          
    219            // Set device as Coordinator
    220            zgDeviceLogicalType = ZG_DEVICETYPE_COORDINATOR;
    221          
    222            HalLedSet ( HAL_LED_1, HAL_LED_MODE_ON );
    223            HalLedSet ( HAL_LED_2, HAL_LED_MODE_ON );
    224            HalLedSet ( HAL_LED_3, HAL_LED_MODE_ON );
    225            HalLedSet ( HAL_LED_4, HAL_LED_MODE_ON );
    226            // To Initiallize
    227            // osal_start_timerEx(task_id, CONFIG_OPTION_EVT, 5000);
    228          }
    229          
    230          /*********************************************************************
    231           * @fn      Sys_ProcessEvent
    232           *
    233           * @brief   Generic Application Task event processor.  This function
    234           *          is called to process all events for the task.  Events
    235           *          include timers, messages and any other user defined events.
    236           *
    237           * @param   task_id  - The OSAL assigned task ID.
    238           * @param   events - events to process.  This is a bit map and can
    239           *                   contain more than one event.
    240           *
    241           * @return  none
    242           */
    243          UINT16 Sys_ProcessEvent( byte task_id, UINT16 events )
    244          {
    245            afIncomingMSGPacket_t *MSGpkt = NULL;
    246            afDataConfirm_t *afDataConfirm;
    247          
    248            // Data Confirmation message fields
    249            byte sentEP;
    250            ZStatus_t sentStatus;
    251            byte sentTransID;       // This should match the value sent
    252            (void)task_id;  // Intentionally unreferenced parameter
    253          
    254            if ( events & SYS_EVENT_MSG )
    255            {
    256              MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( task_id );
    257              while ( MSGpkt )
    258              {
    259                switch ( MSGpkt->hdr.event )
    260                {
    261                  case ZDO_CB_MSG:  // 收到被绑定节点的rsp
    262                    Sys_ProcessZDOMsgs( (zdoIncomingMsg_t *)MSGpkt/*, task_id */);
    263                    break;
    264          
    265                  case AF_DATA_CONFIRM_CMD:
    266                    // This message is received as a confirmation of a data packet sent.
    267                    // The status is of ZStatus_t type [defined in ZComDef.h]
    268                    // The message fields are defined in AF.h
    269                    afDataConfirm = (afDataConfirm_t *)MSGpkt;
    270                    sentEP = afDataConfirm->endpoint;
    271                    sentStatus = afDataConfirm->hdr.status;
    272                    sentTransID = afDataConfirm->transID;
    273                    (void)sentEP;
    274                    (void)sentTransID;
    275          
    276                    // Action taken when confirmation is received.
    277                    if ( sentStatus != ZSuccess )
    278                    {
    279                      // The data wasn't delivered -- Do something
    280                    }
    281                    break;
    282          
    283                  case AF_INCOMING_MSG_CMD:
    284                    Sys_MessageMSGCB( MSGpkt, task_id );
    285                    break;
    286          
    287                  case ZDO_STATE_CHANGE:
    288                    Sys_NwkState = (devStates_t)(MSGpkt->hdr.status);
    289                    if ( (Sys_NwkState == DEV_ZB_COORD) )
    290                    {
    291                    //	if(myAppState == APP_INIT)
    292                    //    osal_start_timerEx( task_id, CLOSE_LIGHT_EVT, 1000);  // 1s 后关了所有的灯
    293                      ;
    294                    }
    295                    
    296                    break;
    297          
    298                  default:
    299                    break;
    300                }
    301          
    302                // Release the memory
    303                osal_msg_deallocate( (uint8 *)MSGpkt );
    304          
    305                // Next
    306                MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( Sys_TaskID );
    307              }
    308              // return unprocessed events
    309              return (events ^ SYS_EVENT_MSG);
    310            }
    311          
    312            if( events & CONFIG_OPTION_EVT )
    313            {
    314              uint8 logicalType;
    315              uint8 startOptions;
    316              if ( myAppState == APP_INIT  )
    317              {
    318                zb_ReadConfiguration( ZCD_NV_LOGICAL_TYPE, sizeof(uint8), &logicalType );
    319                if ( logicalType != ZG_DEVICETYPE_ENDDEVICE )
    320                {
    321                  logicalType = ZG_DEVICETYPE_COORDINATOR;
    322                  zb_WriteConfiguration(ZCD_NV_LOGICAL_TYPE, sizeof(uint8), &logicalType);
    323                }
    324                // Do more configuration if necessary and then restart device with auto-start bit set
    325                // write endpoint to simple desc...dont pass it in start req..then reset
    326          
    327                zb_ReadConfiguration( ZCD_NV_STARTUP_OPTION, sizeof(uint8), &startOptions );
    328                startOptions = ZCD_STARTOPT_AUTO_START;
    329                zb_WriteConfiguration( ZCD_NV_STARTUP_OPTION, sizeof(uint8), &startOptions );
    330                zb_SystemReset();
    331              }
    332              return (events ^ CONFIG_OPTION_EVT);
    333            }
    334          
    335            if(events & CLOSE_LIGHT_EVT)
    336            {
    337              HalLedSet ( HAL_LED_1, HAL_LED_MODE_ON );
    338              HalLedSet ( HAL_LED_2, HAL_LED_MODE_ON );
    339              HalLedSet ( HAL_LED_3, HAL_LED_MODE_ON );
    340              return (events ^ CLOSE_LIGHT_EVT);
    341            }
    342          
    343            // Discard unknown events
    344            return 0;
    345          }
    346          
    347          /*********************************************************************
    348           * Event Generation Functions
    349           */
    350          
    351          /*********************************************************************
    352           * @fn      Sys_ProcessZDOMsgs()
    353           *
    354           * @brief   Process response messages
    355           *
    356           * @param   none
    357           *
    358           * @return  none
    359           */
    360          void Sys_ProcessZDOMsgs( zdoIncomingMsg_t *inMsg /*, byte task_id */)
    361          {
    362          
    363            switch ( inMsg->clusterID )
    364            {
    365              case End_Device_Bind_rsp:
    366                if ( ZDO_ParseBindRsp( inMsg ) == ZSuccess )
    367                {
    368                  // Light LED
    369                  HalLedSet( HAL_LED_4, HAL_LED_MODE_ON );
    370                }
    371          #if defined(BLINK_LEDS)
    372                else
    373                {
    374                  // Flash LED to show failure
    375                  HalLedSet ( HAL_LED_4, HAL_LED_MODE_FLASH );
    376                }
    377          #endif
    378                break;
    379          /*
    380              case Match_Desc_rsp:
    381                { 
    382                  zAddrType_t dstAddr;
    383                  ZDO_ActiveEndpointRsp_t *pRsp = ZDO_ParseEPListRsp( inMsg );
    384                  if ( pRsp )
    385                  {
    386                    if ( pRsp->status == ZSuccess && pRsp->cnt )
    387                    {
    388                      switch (type_join)
    389                      {
    390                        case BUTTON_TYPE_ID:
    391                        {
    392                          for(int i=0; pRsp->cnt<i; i++)
    393                          {
    394                            dstAddr.addrMode = (afAddrMode_t)Addr16Bit;
    395                            dstAddr.addr.shortAddr = pRsp->nwkAddr;
    396          
    397                            if ( APSME_BindRequest( Button_epDesc.simpleDesc->EndPoint,
    398                                  BUTTON_CLUSTERID, &dstAddr, pRsp->epList[i] ) == ZSuccess )
    399                            {
    400                              //Bind Success
    401                              osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV,250);
    402                              // 获取目的设备的短地址---干什么的？
    403                              ZDP_IEEEAddrReq(pRsp->nwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0);
    404          
    405                              zb_BindConfirm(BUTTON_CLUSTERID, ZB_SUCCESS);
    406                            }
    407          
    408                            // Take the first endpoint, Can be changed to search through endpoints
    409                            Button_DstAddr.endPoint = pRsp->epList[i];
    410                          }
    411                          HalLedSet( HAL_LED_4, HAL_LED_MODE_ON );
    412                        }
    413          
    414                        // case Led_TaskID:
    415                      }
    416                    }
    417                    osal_mem_free( pRsp );
    418                  }
    419                }
    420                break;
    421                */
    422            }
    423          }
    424          
    425          /*********************************************************************
    426           * LOCAL FUNCTIONS
    427           */
    428          
    429          /*********************************************************************
    430           * @fn      Sys_MessageMSGCB
    431           *
    432           * @brief   Data message processor callback.  This function processes
    433           *          any incoming data - probably from other devices.  So, based
    434           *          on cluster ID, perform the intended action.
    435           *
    436           * @param   none
    437           *
    438           * @return  none
    439           */
    440          void Sys_MessageMSGCB( afIncomingMSGPacket_t *pkt, byte task_id )
    441          {
    442            switch ( pkt->clusterId )
    443            {
    444              case BUTTON_CLUSTERID:
    445                // "the" message
    446          #if defined( WIN32 )
    447                WPRINTSTR( pkt->cmd.Data );
    448          #endif
    449                break;
    450            }
    451          }
    452          
    453          /*********************************************************************
    454           * @fn      Sys_SendPreBindMessage
    455           * * @brief   Broadcast prebind message.
    456           *
    457           *
    458           * @param   type_id : 想要绑定的终端类型
    459           *
    460           * @return  none
    461           */
    462          void Sys_SendPreBindMessage( byte type_id )
    463          {
    464            afAddrType_t dstAddr;
    465            uint8 endPoint_ID;
    466          
    467            dstAddr.addr.shortAddr = 0xFFFF;
    468            dstAddr.addrMode = (afAddrMode_t)AddrBroadcast;
    469            dstAddr.endPoint = Sys_epDesc.simpleDesc->EndPoint;
    470          
    471            char theMessageData[6] = "bind";
    472            theMessageData[4] = type_id;
    473            endPoint_ID = typeID2pointID(type_id);
    474            theMessageData[5] = endPoint_ID;
    475          
    476            if ( AF_DataRequest( &dstAddr, &Sys_epDesc,
    477                                 SYS_CLUSTERID,
    478                                 (byte)osal_strlen( theMessageData ) + 1,
    479                                 (byte *)&theMessageData,
    480                                 &Sys_TransID,
    481                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
    482            {
    483              // Successfully requested to be sent.
    484              // 闪5s灯
    485              HalLedBlink (HAL_LED_1, 1, 50, 5000);
    486              //if(想要绑定什么就对应的 TypeID)
    487          
    488              type_join = type_id;
    489              if(type_id == BUTTON_TYPE_ID)
    490                osal_start_timerEx(Button_TaskID, MATCH_BIND_EVT, 5000);
    491          
    492            }
    493            else
    494            {
    495              // Error occurred in request to send.
    496              HalLedSet(HAL_LED_1, HAL_LED_MODE_OFF);
    497            }
    498          }
    499          
    500          /*********************************************************************
    501          *********************************************************************/
    502          
    503          
    504          /******************************************************************************
    505           * @fn          zb_StartConfirm
    506           *
    507           * @brief       The zb_StartConfirm callback is called by the ZigBee stack
    508           *              after a start request operation completes
    509           *
    510           * @param       status - The status of the start operation.  Status of
    511           *                       ZB_SUCCESS indicates the start operation completed
    512           *                       successfully.  Else the status is an error code.
    513           *
    514           * @return      none
    515           */
    516          void zb_StartConfirm( uint8 status )
    517          {
    518              if ( status == ZB_SUCCESS )
    519            {
    520              myAppState = APP_START;
    521            }
    522            else
    523            {
    524              // Try again later with a delay
    525          
    526              HalLedSet(HAL_LED_2, HAL_LED_MODE_BLINK);
    527            }
    528          }
    529          /******************************************************************************
    530           * @fn          zb_SendDataConfirm
    531           *
    532           * @brief       The zb_SendDataConfirm callback function is called by the
    533           *              ZigBee after a send data operation completes
    534           *
    535           * @param       handle - The handle identifying the data transmission.
    536           *              status - The status of the operation.
    537           *
    538           * @return      none
    539           */
    540          void zb_SendDataConfirm( uint8 handle, uint8 status )
    541          {
    542          }
    543          /******************************************************************************
    544           * @fn          zb_BindConfirm
    545           *
    546           * @brief       The zb_BindConfirm callback is called by the ZigBee stack
    547           *              after a bind operation completes.
    548           *
    549           * @param       commandId - The command ID of the binding being confirmed.
    550           *              status - The status of the bind operation.
    551           *
    552           * @return      none
    553           */
    554          void zb_BindConfirm( uint16 commandId, uint8 status )
    555          {
    556            if( status == ZB_SUCCESS)
    557            {
    558              // Light D2
    559              HalLedSet(HAL_LED_2, HAL_LED_MODE_OFF);
    560            }
    561            else
    562            {
    563              // Light D3
    564              HalLedSet(HAL_LED_3, HAL_LED_MODE_OFF);
    565            }
    566          }
    567          /******************************************************************************
    568           * @fn          zb_AllowBindConfirm
    569           *
    570           * @brief       Indicates when another device attempted to bind to this device
    571           *
    572           * @param
    573           *
    574           * @return      none
    575           */
    576          void zb_AllowBindConfirm( uint16 source )
    577          {
    578          }
    579          /******************************************************************************
    580           * @fn          zb_FindDeviceConfirm
    581           *
    582           * @brief       The zb_FindDeviceConfirm callback function is called by the
    583           *              ZigBee stack when a find device operation completes.
    584           *
    585           * @param       searchType - The type of search that was performed.
    586           *              searchKey - Value that the search was executed on.
    587           *              result - The result of the search.
    588           *
    589           * @return      none
    590           */
    591          void zb_FindDeviceConfirm( uint8 searchType, uint8 *searchKey, uint8 *result )
    592          {
    593          }
    594          /******************************************************************************
    595           * @fn          zb_ReceiveDataIndication
    596           *
    597           * @brief       The zb_ReceiveDataIndication callback function is called
    598           *              asynchronously by the ZigBee stack to notify the application
    599           *              when data is received from a peer device.
    600           *
    601           * @param       source - The short address of the peer device that sent the data
    602           *              command - The commandId associated with the data
    603           *              len - The number of bytes in the pData parameter
    604           *              pData - The data sent by the peer device
    605           *
    606           * @return      none
    607           */
    608          void zb_ReceiveDataIndication( uint16 source, uint16 command, uint16 len, uint8 *pData  )
    609          {
    610          }
    611          
    612          void zb_HandleOsalEvent( uint16 event )
    613          {
    614            if ( event & MY_START_EVT )
                                ^
Error[Pe020]: identifier "MY_START_EVT" is undefined

  static byte type_join;
              ^
"D:\ProgramData\Hardware\zigbee\Projects\zstack\Samples\SensorSys\Source\SensorSys_Coordinator.c",154  Warning[Pe550]: 
          variable "type_join" was set but never used
    615            {
    616              zb_StartRequest();
    617            }
    618          }
    619          
    620          uint8 typeID2pointID(char type)
    621          {
    622            uint8 rst = 0;
    623            for(char i = 0; i < 8; i++)
    624            {
    625              if(type)
    626              {
    627                rst++;
    628                type = type >> 1;
    629              }
    630            }
    631            return rst;
    632          }
    633          
    634          /******************************************************************************
    635           * @fn          Sensor_BindDevice
    636           *
    637           * @brief       The zb_BindDevice function establishes or removes a ‘binding? *              between two devices.  Once bound, an application can send
    638           *              messages to a device by referencing the commandId for the
    639           *              binding.
    640           *
    641           * @param       create - TRUE to create a binding, FALSE to remove a binding
    642           *              commandId - The identifier of the binding
    643           *              pDestination - The 64-bit IEEE address of the device to bind to
    644           *
    645           * @return      The status of the bind operation is returned in the
    646           *              zb_BindConfirm callback.
    647           */
    648          void Sensor_BindDevice ( uint8 create, uint16 commandId, uint8 *pDestination )
    649          {
    650            zAddrType_t destination;
    651            uint8 ret = ZB_ALREADY_IN_PROGRESS;
    652          
    653            if ( create )
    654            {
    655              if (sensor_bindInProgress == 0xffff)
    656              {
    657                if ( pDestination )
    658                {
    659                  destination.addrMode = Addr64Bit;
    660                  osal_cpyExtAddr( destination.addr.extAddr, pDestination );
    661                    // here was sapi_epDesc.endPoint
    662                  ret = APSME_BindRequest( BUTTON_ENDPOINT, commandId,
    663                                                      &destination, BUTTON_ENDPOINT );
    664          
    665                  if ( ret == ZSuccess )
    666                  {
    667                    // Find nwk addr
    668                    ZDP_NwkAddrReq(pDestination, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
    669                    osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, 250 );
    670                  }
    671                }
    672                else
    673                {
    674                  ret = ZB_INVALID_PARAMETER;
    675                  destination.addrMode = Addr16Bit;
    676                  destination.addr.shortAddr = NWK_BROADCAST_SHORTADDR;
    677                  if ( ZDO_AnyClusterMatches( 1, &commandId, Button_epDesc.simpleDesc->AppNumOutClusters,
    678                                                          Button_epDesc.simpleDesc->pAppOutClusterList ) )
    679                  {
    680                    // Try to match with a device in the allow bind mode
    681                    ret = ZDP_MatchDescReq( &destination, NWK_BROADCAST_SHORTADDR,
    682                        Button_epDesc.simpleDesc->AppProfId, 1, &commandId, 0, (cId_t *)NULL, 0 );
    683                  }
    684                  else if ( ZDO_AnyClusterMatches( 1, &commandId, sapi_epDesc.simpleDesc->AppNumInClusters,
    685                                                          sapi_epDesc.simpleDesc->pAppInClusterList ) )
    686                  {
    687                    ret = ZDP_MatchDescReq( &destination, NWK_BROADCAST_SHORTADDR,
    688                        Button_epDesc.simpleDesc->AppProfId, 0, (cId_t *)NULL, 1, &commandId, 0 );
    689                  }
    690          
    691                  if ( ret == ZB_SUCCESS )
    692                  {
    693                    // Set a timer to make sure bind completes
    694          #if ( ZG_BUILD_RTR_TYPE )
    695                    osal_start_timerEx(Button_TaskID, ZB_BIND_TIMER, AIB_MaxBindingTime);
    696          #else
    697                    // AIB_MaxBindingTime is not defined for an End Device
    698                    osal_start_timerEx(Button_TaskID, ZB_BIND_TIMER, zgApsDefaultMaxBindingTime);
    699          #endif
    700                    sensor_bindInProgress = commandId;
    701                    return; // dont send cback event
    702                  }
    703                }
    704              }
    705          
    706            //  SAPI_SendCback( SAPICB_BIND_CNF, ret, commandId );
    707            }
    708            else
    709            {
    710              // Remove local bindings for the commandId
    711              BindingEntry_t *pBind;
    712          
    713              // Loop through bindings an remove any that match the cluster
    714              while ( pBind = bindFind( BUTTON_ENDPOINT, commandId, 0 ) )
    715              {
    716                bindRemoveEntry(pBind);
    717              }
    718              osal_start_timerEx( ZDAppTaskID, ZDO_NWK_UPDATE_NV, 250 );
    719            }
    720            return;
    721          }
    722          
    723          // The order in this table must be identical to the task initialization calls below in osalInitTask.
    724          
    725          const pTaskEventHandlerFn tasksArr[] = {
    726            macEventLoop,
    727            nwk_event_loop,
    728            Hal_ProcessEvent,
    729          #if defined( MT_TASK )
    730            MT_ProcessEvent,
    731          #endif
    732            APS_event_loop,
    733            ZDApp_event_loop,
    734          
    735            Sys_ProcessEvent,
    736            Button_ProcessEvent,
    737            SAPI_ProcessEvent
    738          };
    739          
    740          const uint8 tasksCnt = sizeof( tasksArr ) / sizeof( tasksArr[0] );
    741          uint16 *tasksEvents;
    742          
    743          
    744          
    745          /*********************************************************************
    746           * @fn      osalInitTasks
    747           *
    748           * @brief   This function invokes the initialization function for each task.
    749           *
    750           * @param   void
    751           *
    752           * @return  none
    753           */
    754          void osalInitTasks( void )
    755          {
    756            uint8 taskID = 0;
    757          
    758            tasksEvents = (uint16 *)osal_mem_alloc( sizeof( uint16 ) * tasksCnt);
    759            osal_memset( tasksEvents, 0, (sizeof( uint16 ) * tasksCnt));
    760          
    761            macTaskInit( taskID++ );
    762            nwk_init( taskID++ );
    763            Hal_Init( taskID++ );
    764          #if defined( MT_TASK )
    765            MT_TaskInit( taskID++ );
    766          #endif
    767            APS_Init( taskID++ );
    768            ZDApp_Init( taskID++ );
    769            Sys_Init( taskID++ );
    770            Button_Init( taskID++ );
    771            SAPI_Init( taskID );
    772          }

Errors: 1
Warnings: 2
